#include <iostream>
#include <ctime>
#include <cmath>
#include <random>
#include <QApplication>
#include <QFileInfo>
#include <QString>
#include <QTextStream>
#include "visualizator.h"
#include "color_selector.h"

extern const int visioVersion(2);
extern const int visioSubversion(14);

bool fileExists(QString path) {
    QFileInfo check_file(path);
    return check_file.exists() && check_file.isFile();
}

int main(int argc, char *argv[])
{

    QApplication a(argc, argv);

    if (argc>1) {                                // console app

        if ((!strcmp(argv[1],"-v")||(!strcmp(argv[1],"version"))||(!strcmp(argv[1],"about"))||(!strcmp(argv[1],"-a")))) {

            std::cout << "Visio " << visioVersion << "." << visioSubversion << std::endl;
            std::cout << "Programmed in C++\n" << std::endl;
            std::cout << "Using:" << std::endl;
            std::cout << "QT 5.6" << std::endl;
            std::cout << "ffmpeg version 3.0.1" << std::endl;
            std::cout << "HDF5-1.8.17 C++ API library" << std::endl;
            std::cout << std::endl;
            std::cout << "Visio is programmed by Marco Strambi (melko)" << std::endl;
            std::cout << "melko.software@gmail.com" << std::endl;
            return 0;

        }        if ((!strcmp(argv[1],"-h")||(!strcmp(argv[1],"help")))) {

            std::cout << "Usage:" << std::endl;
            std::cout << "visio [mode] [parameters]" << std::endl;
            std::cout << "it's possible to run visio in different modes:" << std::endl;
            std::cout << "   \"ray\"           compute raycasting from starting points in random directions" << std::endl;
            std::cout << "   \"movie\"         generate *.mov movie from simulation lists and movie configuration" << std::endl;
            std::cout << "   \"frame\"         generate *.bmp frame picture from simulation lists and movie configuration" << std::endl;
            std::cout << "   \"info\"          info about HDF5 file, to be used with ray casting" << std::endl;
            std::cout << "   \"gui\"           start in GUI mode" << std::endl;
            std::cout << "   \"at\"            display values at chosen coordinates" << std::endl;
            std::cout << "   \"help\" or \"-h\"  display this help page." << std::endl;
            std::cout << "   \"version\" or \"-v\"  display version number." << std::endl;
            std::cout << "Parameters changes depending on the mode, for a list of parameters use" << std::endl;
            std::cout << "visio [mode] -h" << std::endl;
            std::cout << std::endl;
            std::cout << "Visio is programmed by Marco Strambi (melko)" << std::endl;
            std::cout << "melko.software@gmail.com" << std::endl;
            std::cout << "marcaccionero@gmail.com" << std::endl;
            return 0;

        }

        if (!strcmp(argv[1],"at")) {

            std::cout << "Display values." << std::endl;

            if (argc<3) {
                std::cout << "Wrong number of parameters. Try \"visio at -h\"" << std::endl;
                return 1;
            }

            QString inputFile,inputList,inputType,inputConfx,inputConfy,inputConfz,outputFile;
            bool lIsSpecified(false),toStdOutput(true);

            if (!strcmp(argv[2],"-h"))  {
                std::cout << "Usage (at mode):" << std::endl;
                std::cout << "visio at -f [input file] -t [type of file] -l [coordinate file] -c [x] [y] [z] -o [output file]" << std::endl;
                std::cout << "-f: simulation file (choose the \"grid_field_d\" file)" << std::endl;
                std::cout << "-t: type of simulation file (HDF5, HDF5DAHLIA, PLAIN)" << std::endl;
                std::cout << "-c: single coordinate, each value in range 0-1" << std::endl;
                std::cout << "-l: *.txt file generated by user or visio containing the list of coordinate" << std::endl;
                std::cout << "-o: *.txt output file to be generated" << std::endl;
                std::cout << "if -l is specified, -c is ignored. in -o is not specified, standard output" << std::endl;
                std::cout << "will be used to display results." << std::endl;
                return 0;
            }

            for (int i=2; i<argc; i++) {
                if (!strcmp(argv[i],"-c")) {
                    inputConfx=QString(argv[i+1]);
                    inputConfy=QString(argv[i+2]);
                    inputConfz=QString(argv[i+3]);
                }
                if (!strcmp(argv[i],"-f")) {
                    inputFile=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-t")) {
                    inputType=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-l")) {
                    inputList=QString(argv[i+1]);
                    lIsSpecified=true;
                }
                if (!strcmp(argv[i],"-o")) {
                    outputFile=QString(argv[i+1]);
                    toStdOutput=false;
                }
            }

            if ((inputConfx.isEmpty())&&(!lIsSpecified)) {
                std::cout << "Coordinate not specified." << std::endl;
                return 1;
            }

            if ((inputConfy.isEmpty())&&(!lIsSpecified)) {
                std::cout << "Coordinate not specified." << std::endl;
                return 1;
            }

            if ((inputConfz.isEmpty())&&(!lIsSpecified)) {
                std::cout << "Coordinate not specified." << std::endl;
                return 1;
            }

            if (inputFile.isEmpty()) {
                std::cout << "Simulation list file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputFile)) {
                std::cout << "Simulation list file not found, aborting." << std::endl;
                return 1;
            }

            SimType type(HDF5);

            if ((inputType!="PLAIN")&&(inputType!="HDF5")&&(inputType!="HDF5DAHLIA")) {
                std::cout << "Simulation type not recognized, aborting." << std::endl;
                return 1;
            }

            if (inputType=="PLAIN") {
                type=PLAIN;
                std::cout << "PLAIN Simulation type not yet implemented." << std::endl;
                return 2;
            }

            if (inputType=="HDF5") {
                type=HDF5;
            }

            if (inputType=="HDF5DAHLIA") {
                type=HDF5DAHLIA;
            }

            if (outputFile.isEmpty()) {
                std::cout << "Output file missing. Using standard output." << std::endl;
                outputFile="default.mov";
            }

            std::cout << "Reading file " << inputFile.toLocal8Bit().constData() << '\n';
            std::cout << inputList.toLocal8Bit().constData() << " sims list.\n";










            double x,y,z;
            unsigned int n(0);

            std::vector<Coords> sp;

            if (lIsSpecified) {

                QFile file(inputList);

                if(!file.open(QIODevice::ReadOnly|QIODevice::Text)) {
                    std::cout << "Unable to open position file, aborting." << std::endl;
                    return 1;
                }
                QString line;
                QTextStream sl(&file);

                while (true) {
                    do {
                        line=sl.readLine();
                        if (line.isEmpty()) break;
                    } while (line[0]=='#');

                    std::cout << line.toLocal8Bit().constData() << std::endl;
                    if (line.isEmpty()) break;
                    QTextStream ts(&line);
                    ts >> x >> y >> z;
                    n++;
                    sp.push_back(Coords(x+1e-10,y+1e-10,z+1e-10));
                }

                file.close();

                std::cout << "Read " << n << " coordinates" << std::endl;

            } else {

                QTextStream tx(&inputConfx);
                QTextStream ty(&inputConfy);
                QTextStream tz(&inputConfz);
                tx >> x;
                ty >> y;
                tz >> z;
                n++;
                sp.push_back(Coords(x+1e-10,y+1e-10,z+1e-10));
            }


            if (!n) {
                std::cout << "Exiting." << std::endl;
                return 0;
            }

            QString result;

            if ((type==HDF5)||type==HDF5DAHLIA) {

                RawHData *data=new RawHData();
                QStringList lf(h5ListOfFiles(inputFile));
                std::vector<std::string> fileList;

                for (int j=0; j<lf.size(); j++) {

                    std::cout << QString(lf[j]).toUtf8().constData() << std::endl;
                    fileList.push_back(QString(lf[j]).toUtf8().constData());

                }

                if (type==HDF5) {
                    loadHDF5Emma(fileList,data);
                }
                if (type==HDF5DAHLIA) {
                    loadHDF5Dahlia(fileList,data);
                }

                DataPtr pointer;

                for (unsigned int i=0; i<n; i++) {

                    QTextStream ts(&result);
                    ts << "position n." << i+1 << "/" << n << "\n";
                    ts << "coordinate\n";
                    ts << "X   \t   Y   \t   Z\n";


                    ts << sp[i].xPos << "\t" << sp[i].yPos << "\t" << sp[i].zPos <<  "\n";

                    data->infoPos(sp[i],pointer);

                    ts << "Level:\t " << pointer->res << "\n";
                    ts << "Edge :\t " << double(powl(0.5l,pointer->res)) << "\n";
                    ts << "Value:\t " << pointer->val << "\n";
                    ts << "X    :\t " << pointer->x << "\t Delta X:\t " << sp[i].xPos - pointer->x << "\n";
                    ts << "Y    :\t " << pointer->y << "\t Delta Y:\t " << sp[i].yPos - pointer->y << "\n";
                    ts << "Z    :\t " << pointer->z << "\t Delta Z:\t " << sp[i].zPos - pointer->z << "\n";
                    ts << "At   :\t " << data->at(sp[i].xPos,sp[i].yPos,sp[i].zPos) << "\n\n";

                }
            }

            if (toStdOutput) {

                std::cout << result.toUtf8().constData() << std::endl;

            } else {

                QFile ofile(outputFile);
                if(!ofile.open(QIODevice::WriteOnly|QIODevice::Text)) {
                    std::cout << "Unable to open output file, aborting." << std::endl;
                    return 1;
                }
                QTextStream ostore(&ofile);
                ostore << result;
                ofile.close();

            }

            return 0;

        }

        if (!strcmp(argv[1],"movie")) {

            std::cout << "Build movie mode." << std::endl;

            if (argc<3) {
                std::cout << "Wrong number of parameters. Try \"visio movie -h\"" << std::endl;
                return 1;
            }

            QString inputList,inputConf,outputFile;

            if (!strcmp(argv[2],"-h"))  {
                std::cout << "Usage (movie mode):" << std::endl;
                std::cout << "visio movie -c [configuration file] -l [list file] -o [output file]" << std::endl;
                std::cout << "-c: *.mcf file generated by visio containing the movie parameters" << std::endl;
                std::cout << "-l: *.txt file generated by user or visio containing the list of simulations" << std::endl;
                std::cout << "-o: *.mov movie file to be generated" << std::endl;
                std::cout << "A list of *.bmp frames will be saved in [Home]/.visio_movie/tmp_frames/" << std::endl;
                return 0;
            }

            for (int i=2; i<argc; i++) {
                if (!strcmp(argv[i],"-c")) {
                    inputConf=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-l")) {
                    inputList=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-o")) {
                    outputFile=QString(argv[i+1]);
                }
            }

            if (inputConf.isEmpty()) {
                std::cout << "Movie parameters file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputConf)) {
                std::cout << "Movie parameter file not found, aborting." << std::endl;
                return 1;
            }

            if (inputList.isEmpty()) {
                std::cout << "Simulation list file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputList)) {
                std::cout << "Simulation list file not found, aborting." << std::endl;
                return 1;
            }

            if (outputFile.isEmpty()) {
                std::cout << "Output file missing. Using \"default.mov\"" << std::endl;
                outputFile="default.mov";
            }

            std::cout << "Building MOV file " << outputFile.toLocal8Bit().constData() << '\n';
            std::cout << inputConf.toLocal8Bit().constData() << " conf file,\n";
            std::cout << inputList.toLocal8Bit().constData() << " sims list.\n";

            Visualizator v;

            v.loadConf(inputConf);
            v.loadSims(inputList);
            v.saveMovie(outputFile);

            return 0;

        }

        if (!strcmp(argv[1],"frame")) {

            std::cout << "Render frame mode." << std::endl;

            if (argc<3) {
                std::cout << "Wrong number of parameters. Try \"visio frame -h\"" << std::endl;
                return 1;
            }

            QString inputList,inputConf,outputFile;
            int frameNumber(0);

            if (!strcmp(argv[2],"-h")) {
                std::cout << "Usage (frame mode):" << std::endl;
                std::cout << "visio frame -c [configuration file] -l [list file] -n [#] -o [output file]" << std::endl;
                std::cout << "-c: *.mcf file generated by visio containing the movie parameters" << std::endl;
                std::cout << "-l: *.txt file generated by user or visio containing the list of simulations" << std::endl;
                std::cout << "-n: frame number" << std::endl;
                std::cout << "-o: *.bmp frame file to be generated" << std::endl;
                std::cout << "A list of *.bmp frames will be saved in [Home]/.visio_movie/tmp_frames/" << std::endl;
                return 0;
            }

            for (int i=2; i<argc; i++) {
                if (!strcmp(argv[i],"-c")) {
                    inputConf=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-l")) {
                    inputList=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-o")) {
                    outputFile=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-n")) {
                    frameNumber=QString(argv[i+1]).toInt();
                }
            }

            if (inputConf.isEmpty()) {
                std::cout << "Movie parameters file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputConf)) {
                std::cout << "Movie parameter file not found, aborting." << std::endl;
                return 1;
            }

            if (inputList.isEmpty()) {
                std::cout << "Simulation list file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputList)) {
                std::cout << "Simulation list file not found, aborting." << std::endl;
                return 1;
            }

            if (outputFile.isEmpty()) {
                std::cout << "Output file missing. Using \"default.bmp\"" << std::endl;
                outputFile="default.bmp";
            }

            std::cout << "Building BMP file " << outputFile.toLocal8Bit().constData() << '\n';
            std::cout << inputConf.toLocal8Bit().constData() << " conf file,\n";
            std::cout << inputList.toLocal8Bit().constData() << " sims list.\n";
            std::cout << "Taking frame n." << frameNumber << std::endl;

            Visualizator v;

            v.loadConf(inputConf);
            v.loadSims(inputList);
            v.saveFrame(outputFile,frameNumber);

            return 0;

        }

        if (!strcmp(argv[1],"ray")) {

            std::cout << "Ray casting mode." << std::endl;
            QString inputPos,inputSim,inputType,outputFile;
            double len(1.0);
            unsigned int numberOfRays(100),seed(time(NULL));

            if (argc<3) {
                std::cout << "Wrong number of parameters. Try \"visio ray -h\"" << std::endl;
                return 1;
            }

            if (!strcmp(argv[2],"-h"))  {
                std::cout << "Usage (ray casting mode):" << std::endl;
                std::cout << "visio ray -p [positions file] -n [#] -l [length] -s [seed] -f [simulation file] -t [type of file] -o [output file]" << std::endl;
                std::cout << "-p: *.txt with a list of starting positions for raycasting" << std::endl;
                std::cout << "-n: number of random rays casted from each position" << std::endl;
                std::cout << "-l: length of the ray in terms of universe edge. The default value is 1" << std::endl;
                std::cout << "-s: integer seed for random number generation (default is time)" << std::endl;
                std::cout << "-f: simulation file (if HDF5 emma file, choose the \"grid_field_d\" file)" << std::endl;
                std::cout << "-t: type of simulation file (HDF5, HDF5DAHLIA, PLAIN)" << std::endl;
                std::cout << "-o: *.txt output file" << std::endl;
                return 0;
            }

            for (int i=2; i<argc; i++) {
                if (!strcmp(argv[i],"-p")) {
                    inputPos=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-n")) {
                    numberOfRays=QString(argv[i+1]).toInt();
                }
                if (!strcmp(argv[i],"-l")) {
                    len=QString(argv[i+1]).toDouble();
                }
                if (!strcmp(argv[i],"-s")) {
                    seed=(QString(argv[i+1]).toInt());
                }
                if (!strcmp(argv[i],"-f")) {
                    inputSim=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-t")) {
                    inputType=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-o")) {
                    outputFile=QString(argv[i+1]);
                }
            }


            if (inputPos.isEmpty()) {
                std::cout << "Positions file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputPos)) {
                std::cout << "Positions file not found, aborting." << std::endl;
                return 1;
            }

            if (inputSim.isEmpty()) {
                std::cout << "Simulation file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputSim)) {
                std::cout << "Simulation file not found, aborting." << std::endl;
                return 1;
            }

            SimType type(HDF5);

            if ((inputType!="PLAIN")&&(inputType!="HDF5")&&(inputType!="HDF5DAHLIA")) {
                std::cout << "Simulation type not recognized, aborting." << std::endl;
                return 1;
            }

            if (inputType=="PLAIN") {
                type=PLAIN;
                std::cout << "PLAIN Simulation type not yet implemented." << std::endl;
                return 2;
            }

            if (inputType=="HDF5") {
                type=HDF5;
            }

            if (inputType=="HDF5DAHLIA") {
                type=HDF5DAHLIA;
            }

            if (outputFile.isEmpty()) {
                std::cout << "Output file missing. Using \"default.txt\"" << std::endl;
                outputFile="default.txt";
            }

            std::cout << "Building TXT file " << outputFile.toLocal8Bit().constData() << '\n';
            std::cout << inputPos.toLocal8Bit().constData() << " position file,\n";
            std::cout << inputSim.toLocal8Bit().constData() << " simulation file.\n";
            std::cout << "Casting " << numberOfRays << " rays for each starting position." << std::endl;
            std::cout << "Each ray is " << len << " UE." << std::endl;

            std::vector<Coords> sp;

            QFile file(inputPos);

            if(!file.open(QIODevice::ReadOnly|QIODevice::Text)) {
                std::cout << "Unable to open position file, aborting." << std::endl;
                return 1;
            }

            double x,y,z,phi,theta;
            unsigned int n(0);
            QString line;
            QTextStream sl(&file);

            while (true) {
                do {
                    line=sl.readLine();
                    if (line.isEmpty()) break;
                } while (line[0]=='#');

                std::cout << line.toLocal8Bit().constData() << std::endl;
                if (line.isEmpty()) break;
                QTextStream ts(&line);
                ts >> x >> y >> z;
                n++;
                sp.push_back(Coords(x+1e-10,y+1e-10,z+1e-10));
            }

            file.close();

            std::cout << "Read " << n << " starting positions, casting " << n*numberOfRays << " rays." << std::endl;

            if (!n) {
                std::cout << "Exiting." << std::endl;
                return 0;
            }

            std::vector<QString> posResult(n,"");
            std::vector<Coords> dirResult(n);
            std::vector<std::vector<QString> > result(numberOfRays,posResult);
            std::vector<std::vector<Coords> > dir(numberOfRays,dirResult);

            std::mt19937 generator(seed);
            std::uniform_real_distribution<double> uniform01(0.0, 1.0);

            if ((type==HDF5)||type==HDF5DAHLIA) {

                RawHData *data=new RawHData();
                QStringList lf(h5ListOfFiles(inputSim));
                std::vector<std::string> fileList;
                for (int j=0; j<lf.size(); j++) {

                    std::cout << QString(lf[j]).toUtf8().constData() << std::endl;
                    fileList.push_back(QString(lf[j]).toUtf8().constData());

                }

                if (type==HDF5) {
                    loadHDF5Emma(fileList,data);
                }
                if (type==HDF5DAHLIA) {
                    loadHDF5Dahlia(fileList,data);
                }

                for (unsigned int i=0; i<n; i++) {

                    for (unsigned int j=0; j<numberOfRays; j++) {

                        theta = 2 * M_PI * uniform01(generator);
                        phi = acos(1 - 2 * uniform01(generator));
                        x = sin(phi) * cos(theta);
                        y = sin(phi) * sin(theta);
                        z = cos(phi);
                        Coords dr(x,y,z);
                        dr=dr.unit();
                        dir[j][i]=dr;
                        QTextStream ts(&result[j][i]);

                        ts << SaveStraightLineHDF5(dr, sp[i], data, len);
                    }
                }
            }

            QFile ofile(outputFile);
            if(!ofile.open(QIODevice::WriteOnly|QIODevice::Text)) {
                std::cout << "Unable to open output file, aborting." << std::endl;
                return 1;
            }
            QTextStream ostore(&ofile);
            for (unsigned int i=0; i<n; i++) {
                for (unsigned int j=0; j<numberOfRays; j++) {
                    ostore << result[j][i];

                }
            }
            ofile.close();

            return 0;

        }

        if (!strcmp(argv[1],"info")) {

            std::cout << "Info mode." << std::endl;
            QString inputSim,outputFile,inputType;
            int level(0);
            double minv(0),maxv(0);
            bool toStdOutput(false),minb(true),maxb(true);

            if (argc<3) {
                std::cout << "Wrong number of parameters. Try \"visio info -h\"" << std::endl;
                return 1;
            }

            if (!strcmp(argv[2],"-h"))  {
                std::cout << "Usage (info mode):" << std::endl;
                std::cout << "visio info -f [HDF5 Emma simulation file] -l [level] -n [min val] -m [max val] -o [output file]" << std::endl;
                std::cout << "-f: simulation file (choose the \"grid_field_d\" file)" << std::endl;
                std::cout << "-t: type of simulation file (HDF5, HDF5DAHLIA, PLAIN)" << std::endl;
                std::cout << "-l: integer level of detail" << std::endl;
                std::cout << "-n: filter result which value is less then min val" << std::endl;
                std::cout << "-m: filter result which value is more then max val" << std::endl;
                std::cout << "-o: *.txt output file" << std::endl;
                std::cout << "if -o is not specified, info will be printed on standard output" << std::endl;
                std::cout << "if -l is not specified or set to 0, generic info about the simulation file will" << std::endl;
                std::cout << "-be printed" << std::endl;
                std::cout << "if both -l and -o are specified, the resulting file is a position compatible file for ray mode." << std::endl;
                return 0;
            }

            for (int i=2; i<argc; i++) {
                if (!strcmp(argv[i],"-l")) {
                    level=(QString(argv[i+1]).toInt());
                    if (level<0) level=-level;
                }
                if (!strcmp(argv[i],"-n")) {
                    minv=(QString(argv[i+1]).toDouble());
                    minb=false;
                }
                if (!strcmp(argv[i],"-m")) {
                    maxv=(QString(argv[i+1]).toDouble());
                    maxb=false;
                }
                if (!strcmp(argv[i],"-f")) {
                    inputSim=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-t")) {
                    inputType=QString(argv[i+1]);
                }
                if (!strcmp(argv[i],"-o")) {
                    outputFile=QString(argv[i+1]);
                }
            }
            if (inputSim.isEmpty()) {
                std::cout << "Simulation file not entered, aborting." << std::endl;
                return 1;
            }

            if (!fileExists(inputSim)) {
                std::cout << "Simulation file not found, aborting." << std::endl;
                return 1;
            }

            SimType type(HDF5);

            if ((inputType!="PLAIN")&&(inputType!="HDF5")&&(inputType!="HDF5DAHLIA")) {
                std::cout << "Simulation type not recognized, aborting." << std::endl;
                return 1;
            }

            if (inputType=="PLAIN") {
                type=PLAIN;
                std::cout << "PLAIN Simulation type not yet implemented." << std::endl;
                return 2;
            }

            if (inputType=="HDF5") {
                type=HDF5;
            }

            if (inputType=="HDF5DAHLIA") {
                type=HDF5DAHLIA;
            }


            if (outputFile.isEmpty()) {
                std::cout << "Results on std output" << std::endl;
                toStdOutput=true;
            } else {
                std::cout << "Building TXT file " << outputFile.toLocal8Bit().constData() << ".\n";
            }
            std::cout << inputSim.toLocal8Bit().constData() << " simulation file.\n";

            std::vector<Coords> sp;

            RawHData *data=new RawHData();
            QStringList lf(h5ListOfFiles(inputSim));
            std::vector<std::string> fileList;
            for (int j=0; j<lf.size(); j++) {

                std::cout << QString(lf[j]).toUtf8().constData() << std::endl;
                fileList.push_back(QString(lf[j]).toUtf8().constData());

            }

            if (type==HDF5) {
                loadHDF5Emma(fileList,data);
            }
            if (type==HDF5DAHLIA) {
                loadHDF5Dahlia(fileList,data);
            }

            QString out;
            QTextStream output(&out);
            int mx;

            if (minb) minv=data->min()-1.0;
            if (maxb) maxv=data->max()+1.0;

            if (level) {

                std::vector<DataPtr> listOfId=data->listLev(level);
                for (unsigned int i=0; i<listOfId.size(); i++) {

                    double r=powl(0.5,listOfId[i]->res);
                    if (((listOfId[i]->val>minv)||(minb))&&((listOfId[i]->val<maxv)||(maxb)))
                        output << listOfId[i]->x+r/2.0 << " " << listOfId[i]->y+r/2.0 << " " << listOfId[i]->z+r/2.0 << " " << listOfId[i]-> val << '\n';

                }

            } else {
                std::vector<int> lvls=data->searchForLevel(minv,maxv);
                output << "File name :" << inputSim << '\n';
                output << "Size      :" << data->length() << " points\n";
                output << "Max value :" << data->max() << "\n";
                output << "Min value :" << data->min() << "\n";
                output << "Max level :" << (mx=data->maxLev()) << "\n";
                output << "Min level :" << data->minLev() << "\n";
                if ((!minb)&&(!maxb)) {
                    output << "Points in range " << minv << " <> " << maxv << "\n";
                }
                if ((minb)&&(!maxb)) {
                    output << "Points less than " << maxv << "\n";
                }
                if ((!minb)&&(maxb)) {
                    output << "Points greater than " << minv << "\n";
                }
                for (int i=0; i<=mx; i++) {
                    output << "Level " << i << ": " << lvls[i] << " points\n";
                }
            }

            if (toStdOutput) {

                std::cout << out.toLocal8Bit().constData() << std::endl;

            } else {

                QFile ofile(outputFile);
                if(!ofile.open(QIODevice::WriteOnly|QIODevice::Text)) {
                    std::cout << "Unable to open output file, aborting." << std::endl;
                    return 1;
                }
                QTextStream ostore(&ofile);
                ostore << out;
                ofile.close();
            }

            return 0;

        }

        if (strcmp(argv[1],"gui")) {

            std::cout << "Mode undefined." << std::endl;
            return 1;

        }

    }
                                                // GUI app

    std::cout << "GUI mode" << std::endl;
    Visualizator v(true);
    v.show();

    return a.exec();

}
